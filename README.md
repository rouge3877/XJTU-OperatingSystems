# 动态模块的加载 与 设备驱动

## `lkm`

- 本模块是一个基础的内核加载和卸载示例，通过`printk`输出加载与卸载信息。

### 设计要点
- **加载时输出信息**：模块加载时通过 `printk` 输出 `"bt: module loaded"`。
- **卸载时输出信息**：模块卸载时通过 `printk` 输出 `"bt: module removed"`。
- **模块初始化与清理**：使用 `module_init` 和 `module_exit` 宏简洁地定义了模块的加载和卸载函数。

### 工作原理
1. **模块加载**：当模块被加载时，`lkm_init` 函数被调用，输出加载信息。
2. **模块卸载**：当模块被卸载时，`lkm_exit` 函数被调用，输出卸载信息。

### 使用场景
- 用作内核模块开发的基础模板，帮助理解内核模块的生命周期管理。


## `modify_syscall`

- 本模块实现了对指定系统调用（如系统调用编号为96的syscall）的修改。
- 通过直接修改内核的`sys_call_table`，将指定的系统调用替换为自定义函数，实现自定义行为。
- 提供了保护机制，禁用并启用写保护，确保修改系统调用表时不会被内核的内存保护机制阻止。

### 设计要点
- **自定义函数替换**：通过 `hello` 函数替换原有的系统调用，修改后的函数会简单地打印信息并返回参数之和。
- **内存保护控制**：通过 `disable_write_protection` 和 `enable_write_protection` 函数，手动禁用和恢复内核的写保护，允许修改`sys_call_table`。
- **系统调用恢复**：模块卸载时，通过 `restore_syscall` 恢复原始的系统调用行为，避免对系统稳定性产生长久影响。

### 工作原理
1. 通过硬编码的方式定位 `sys_call_table` 的地址。
2. 修改系统调用表中的指定位置（`syscall 96`）的函数指针。
3. 新的系统调用将执行 `hello` 函数，打印信息并返回 `di + si` 的结果。
4. 卸载模块时，恢复系统调用表的原始值。

### 模块初始化与卸载
- **加载模块**：替换系统调用并打印调试信息。
- **卸载模块**：恢复原始系统调用表，避免系统崩溃。

### bug
1. 开始是未设置写保护，导致内核崩溃。
2. 修复后，未正确找到`sys_call_table`的地址，导致无法修改系统调用。
3. 找到后，修改系统调用表后，系统调用无法正常返回。
4. 修复计算方法后，使用`syscall(96, 1, 2)`测试，发现返回值不正确。
5. :(

## `global_var`

- 实现了一个基础的字符设备，通过自定义的 `read` 和 `write` 操作，实现内核与用户空间的交互。
- 通过全局变量与用户空间进行数据传递，展示了内核模块如何处理输入输出操作。

### 设计要点
- **字符设备注册**：模块加载时，通过 `register_chrdev` 注册一个字符设备，主设备号为 290。
- **文件操作结构**：通过 `file_operations` 结构体，将 `read` 和 `write` 操作与相应的函数 (`globalvar_read` 和 `globalvar_write`) 绑定，实现对设备的读写操作。
- **数据传输**：使用 `copy_to_user` 和 `copy_from_user` 实现内核与用户空间之间的数据传输，确保数据安全高效地读写。

### 工作原理
1. **模块加载**：调用 `init_mymodule` 函数，注册字符设备并输出加载成功信息。
2. **读取操作**：当用户读取设备时，`globalvar_read` 将内核中的 `global_var` 变量值复制到用户空间。
3. **写入操作**：当用户写入数据时，`globalvar_write` 将用户空间的数据复制到内核中的 `global_var` 变量。
4. **模块卸载**：调用 `cleanup_mymodule` 函数，注销字符设备。

### 使用场景
- 适用于简单的内核模块开发，展示了如何通过字符设备实现内核与用户空间的数据交互。
- 适合用作字符设备驱动开发的基础示例。

## `ascii_char_dev`

- 实现了一个基于字符设备的消息通信系统，支持广播与私聊功能。
- 提供消息队列管理，能够处理多个用户的消息读取与发送。
- 对每条消息添加读取计数，当所有用户读取完消息时，消息自动删除。
- 设备支持并发操作，通过信号量和等待队列确保读写安全。

### 设计要点
1. **消息结构**：每条消息包含发送者PID、接收者PID（0表示广播）、内容及已读取用户数。
2. **多用户支持**：利用原子计数器`user_count`跟踪当前打开设备的用户数量。
3. **私聊和广播**：支持私聊（通过@PID格式指定目标PID）和广播消息（接收者PID为0）。
4. **消息读取计数**：每条消息都有一个`read_count`，当所有用户读取该消息时，消息会从队列中删除。
5. **消息队列**：使用链表存储消息，若消息队列满，则会删除最旧的消息。

### 工作原理
1. **写入操作**：
   - 用户向设备写入消息时，设备会解析消息内容，支持私聊与广播。
   - 消息存储在内核空间的链表中，最多可存储`BUFFER_SIZE`条消息。
   
2. **读取操作**：
   - 用户读取时，设备检查消息队列并返回匹配的消息。
   - 消息内容会拷贝到用户空间，支持多用户并发读取。
   - 读取后，更新`read_count`，当所有用户读取完成后删除消息。

3. **同步机制**：
   - 使用信号量(`semaphore`)实现对设备的读写互斥。
   - 使用等待队列(`wait_queue`)实现消息的异步处理和阻塞读取。

### 注意事项
- 设备支持并发读写操作，适用于多进程环境。
- 设备限制最大消息数为1024条，消息内容最大为512字节。
- 消息在读取完成后会被自动删除，避免内存泄漏。

### 模块初始化与卸载
- **初始化**：分配设备号、初始化字符设备、创建消息队列、设置信号量等。
- **清理**：删除所有消息、注销设备号、清除字符设备。

### bug
1. 读取时，若读取的是广播消息，会存在一个进程多次读取，导致其他进程无法读取。