# 实验二：进程通信与内存管理实验

### 实验内容概述
实验二旨在通过编程实现操作系统中三个关键模块的功能：进程通信（软中断和管道通信）、内存管理（页面置换）。通过编写实验代码并对现象进行分析，理解以下操作系统设计原理：

1. 软中断通信：学习信号机制在 UNIX/Linux 系统中的应用，掌握进程间协作的原理。
2. 管道通信：通过匿名管道实现进程间的同步与互斥通信，体会数据传输的特点。
3. 页面置换算法：通过 FIFO 和 LRU 算法的模拟，实现虚拟内存中的页面管理，验证程序局部性和缺页率的概念。

---

## Part1：软中断通信

### 实验目标
通过实现父子进程间的信号通信，探索以下关键原理：
1. 进程通信：基于 POSIX 标准的信号机制，使用 `SIGINT`、`SIGQUIT` 等信号进行中断通信。
2. 信号处理机制：理解信号捕获 (`signal`) 和屏蔽 (`sigprocmask`) 的设计及用途。
3. 父子进程协作：通过信号完成进程同步，模拟进程结束与资源回收。


### 实验原理

#### 信号机制
- 信号定义：信号是 UNIX/Linux 系统中用于通知进程发生事件的一种软件中断机制。
- 常用信号：
  - `SIGINT` (Ctrl+C)：进程中断。
  - `SIGQUIT` (Ctrl+\)：进程退出。
  - `SIGALRM`：定时闹钟信号。

#### 信号捕获与屏蔽
1. 捕获：
   - 使用 `signal()` 设置自定义信号处理函数。
2. 屏蔽：
   - 使用 `sigprocmask()` 屏蔽指定信号，确保信号处理逻辑在关键代码段执行完后再处理。



### 实验代码功能
1. 父进程创建两个子进程：
   - 使用 `fork()` 系统调用。
   - 子进程与父进程共享代码和数据。
2. 信号处理流程：
   - 父进程捕获 `SIGINT` 和 `SIGQUIT` 信号，在 5 秒内监听用户输入。
   - 父进程通过 `kill()` 向子进程发送 `SIGSTKFLT` 和 `SIGCHLD` 信号，通知子进程终止。
3. 子进程行为：
   - 等待信号到来，通过 `pause()` 挂起。
   - 接收到信号后输出终止信息并退出。



### 运行与观察
#### 运行代码
使用以下命令编译和运行：
```bash
make all && make signal
```

#### 实验现象
1. 5 秒内按下 `Ctrl+C` 或 `Ctrl+\`：
   - 父进程捕获信号并终止两个子进程，输出：
     ```
     Child process 1 is killed by parent!!
     Child process 2 is killed by parent!!
     Parent process is killed!!
     ```
2. 超过 5 秒无输入：
   - 父进程通过 `SIGALRM` 信号结束进程，现象相同。

### Advanced
1. 信号处理(`reentrant`)
    * 信号处理函数中不宜执行耗时操作，应尽量简洁。
    * 信号处理函数中不宜使用 `printf()` 等标准 I/O 函数，应使用 `write()` 等异步安全函数。
    * 信号处理函数中不宜调用不可重入函数，如 `malloc()`、`free()` 等。
    * 信号处理函数中不宜调用系统调用，如 `sleep()`、`wait()` 等。

2. multi-process debug
    * `info inferiors`：查看当前进程信息。
    * `attach <pid>`：调试指定进程。
    * `detach`：退出调试。
    * `set follow-fork-mode child`：子进程继承父进程的调试状态。



## Part2: 管道通信

### 实验目标
通过实现父子进程共享管道通信，验证以下内容：
1. 进程间通信原理：匿名管道作为共享内存的一种实现形式。
2. 同步与互斥机制：通过 `lockf()` 实现管道写入的互斥访问。

### 实验原理

#### 管道通信
- 定义：管道是一种半双工的通信机制，通过内核提供的缓冲区实现数据传输。
- 匿名管道：
  - 仅适用于父子进程。
  - 通过 `pipe(fd)` 创建，`fd[0]` 为读端，`fd[1]` 为写端。

#### 同步与互斥
- 互斥问题：若多个进程同时写入管道，数据可能交错，导致不可预测的输出。
- 解决方案：使用 `lockf()` 实现管道锁定，确保写入操作的互斥性。

### 实验代码功能
1. 父进程创建管道，并生成两个子进程：
   - 子进程分别向管道写入 2000 个字符 `1` 和 `2`。
2. 父进程从管道中读取数据并打印。
3. 比较有锁和无锁情况下的输出差异。



### 运行与观察
#### 运行代码
使用以下命令编译和运行：
```bash
make all && make pipe
```

#### 实验现象
1. 有锁：
   - 子进程依次写入，父进程按顺序读取完整数据：
     ```
     111...111222...222
     ```
2. 无锁：
   - 子进程并发写入，父进程读取到交错数据：
     ```
     112112122... (交错输出)
     ```

### Advanced
1. wirte more, read less
    * 对于`pipe`，如果写入两次，读取一次，当不考虑缓冲区大小时：
    * 管道的顺序特性：

        * 管道是 FIFO（先进先出）结构，写入的数据按照顺序排队，读取时依次取出。
        * 如果读进程在写入未完成时被调度运行，它会从管道中读取已经写入的数据，而第二次写入的数据尚未进入管道。
    * 进程切换引发的数据竞争：
        * 如果一个读进程在第一次写入后被调度运行，它可能会读取所有已经写入的数据，使得第二次写入的数据不会被该次读取捕获。
        * 第二次写入后，这些新数据将留在管道中等待下一次读取。
    * 结果表现：
        * 第一次写入的数据可能被立即读取，后续写入的数据需要等待下次读取。
        * 若读进程未能读取完整数据，可能导致后续数据在管道中累积，直到再次读取为止。

2. 查看pipe
    * `/proc/<pid>/fdinfo/3`：查看进程的文件描述符信息，其中 `3` 为管道文件描述符。
    * `lsof -p <pid>`：查看进程打开的文件描述符，包括管道。

3. pipe fifo sysvpic
    * pipe：匿名管道，只能用于父子进程通信。
    * fifo：命名管道，可用于任意进程通信。
    * sysvipc：System V IPC 机制，包括消息队列、共享内存和信号量。


## Part4: 页面置换

### 实验目标
通过模拟页面置换算法，理解虚拟存储系统的以下原理：
1. 页面置换策略：FIFO 和 LRU 算法的思想及性能差异。
2. 程序局部性原理：验证 LRU 算法在高局部性程序中的优势。
3. 缺页率分析：通过实验计算和比较缺页率。



### 实验原理

#### 虚拟存储与页面置换
- 虚拟存储：允许程序运行所需的地址空间大于物理内存，通过分页实现按需加载。
- 页面置换：
  - 当物理内存已满且需加载新页面时，系统选择替换一个页面。

#### 页面置换算法
1. FIFO：
   - 先入先出策略，淘汰最早进入的页面。
   - 缺点：可能导致 Belady 现象（页面增多却增加缺页率）。
2. LRU：
   - 替换最近最久未使用的页面。
   - 优点：体现程序局部性，性能较优。
   - 缺点：实现复杂度高，需要维护访问时间戳。



### 实验代码功能
1. 用户输入：
   - 页面序列（随机或手动生成）。
   - 页面置换算法（FIFO 或 LRU）。
2. 输出：
   - 页面置换过程。
   - 缺页数和缺页率。



### 运行与观察
#### 运行代码
```bash
make all && make page
```

#### 实验现象
1. FIFO：
   - 页面按照先入先出策略替换，缺页率较高。
   - 输出示例：
     ```
     Page 1 -> [  1  -  - ]  miss 😱
     ...
     Total Page Faults: 5
     Page Fault Rate: 50.00%
     ```
2. LRU：
   - 页面根据最近最久未使用策略替换，缺页率较低。

3. Belady 现象
    - FIFO 算法在页面数增多时缺页率可能增加。`1 2 3 4 1 2 5 1 2 3 4 5`
    - LRU 算法在高局部性程序中表现更好。

4. 缺页率比较
    - LRU 算法的缺页率通常低于 FIFO 算法。
